

 > 在看本文之前，可以先复习前面的一篇文章：《03-JavaScript基础/07-对象简介和对象的基本操作.md》

## 创建自定义对象的几种方法

### 方式一：对象字面量

**对象的字面量**就是一个{}。里面的属性和方法均是**键值对**。

例如：

```javascript
var o = {
            name: "生命壹号",
            age: 26,
            isBoy: true,
            sayHi: function() {
                console.log(this.name);
            }
        };

console.log(o);
```

控制台输出：

![](http://img.smyhvae.com/20180125_1834.png)

### 方式二：工厂模式

通过该方法可以大批量的创建对象。

```javascript
        /*
         * 使用工厂方法创建对象
         *  通过该方法可以大批量的创建对象
         */
        function createPerson(name, age, gender) {
            //创建一个新的对象
            var obj = new Object();
            //向对象中添加属性
            obj.name = name;
            obj.age = age;
            obj.gender = gender;
            obj.sayName = function() {
                alert(this.name);
            };
            //将新的对象返回
            return obj;
        }

        var obj2 = createPerson("猪八戒", 28, "男");
        var obj3 = createPerson("白骨精", 16, "女");
        var obj4 = createPerson("蜘蛛精", 18, "女");
```

**弊端：**

使用工厂方法创建的对象，使用的构造函数都是Object。**所以创建的对象都是Object这个类型，就导致我们无法区分出多种不同类型的对象**。

### 方式三：利用构造函数

```javascript
        //利用构造函数自定义对象
        var stu1 = new Student("smyh");
        console.log(stu1);
        stu1.sayHi();

        var stu2 = new Student("vae");
        console.log(stu2);
        stu2.sayHi();


        // 创建一个构造函数
        function Student(name) {
            this.name = name;    //this指的是构造函数中的对象实例
            this.sayHi = function () {
                console.log(this.name + "厉害了");
            }
        }
```

打印结果：

![](http://img.smyhvae.com/20180125_1350.png)

接下来，我们专门来讲一下构造函数。

## 构造函数

### 代码引入


```javascript
      // 创建一个构造函数，专门用来创建Person对象
      function Person(name, age, gender) {
        this.name = name;
        this.age = age;
        this.gender = gender;
        this.sayName = function() {
          alert(this.name);
        };
      }

      function Dog() {}

      var per = new Person("孙悟空", 18, "男");
      var per2 = new Person("玉兔精", 16, "女");
      var per3 = new Person("奔波霸", 38, "男");

      var dog = new Dog();
```


### 构造函数和普通函数的区别

构造函数就是一个普通的函数，创建方式和普通函数没有区别，不同的是构造函数习惯上首字母大写。

构造函数和普通函数的区别就是**调用方式**的不同：普通函数是直接调用，而构造函数需要使用new关键字来调用。

**this的指向也有所不同**：

- 1.以函数的形式调用时，this永远都是window。比如`fun();`相当于`window.fun();`

- 2.以方法的形式调用时，this是调用方法的那个对象

- 3.以构造函数的形式调用时，this是新创建的那个对象

### new 一个构造函数的执行流程

（1）开辟内存空间，存储新创建的对象

（2）将新建的对象设置为构造函数中的this，在构造函数中可以使用this来引用 新建的对象

（3）执行函数中的代码（包括设置对象属性和方法等）

（4）将新建的对象作为返回值返回

因为this指的是new一个Object之后的对象实例。于是，下面这段代码：

```javascript
        // 创建一个函数
        function createStudent(name) {
            var student = new Object();
            student.name = name;      //第一个name指的是student对象定义的变量。第二个name指的是createStudent函数的参数。二者不一样
        }
```

可以改进为：

```javascript
        // 创建一个函数
        function Student(name) {
            this.name = name;       //this指的是构造函数中的对象实例
        }

```

注意上方代码中的注释。

### 类、实例

使用同一个构造函数创建的对象，我们称为一类对象，也将一个构造函数称为一个**类**。

通过一个构造函数创建的对象，称为该类的**实例**。


### instanceof

使用 instanceof 可以检查**一个对象是否为一个类的实例**。

**语法如下**：

```javascript
对象 instanceof 构造函数
```

如果是，则返回true；否则返回false。

**代码举例**：

```javascript
      function Person() {}

      function Dog() {}

      var person1 = new Person();

      var dog1 = new Dog();

      console.log(person1 instanceof Person); // 打印结果： true
      console.log(dog1 instanceof Person); // 打印结果：false

      console.log(dog1 instanceof Object); // 所有的对象都是Object的后代。因此，打印结果为：true
```

根据上方代码中的最后一行，需要补充一点：**所有的对象都是Object的后代，因此任何对象和Object左instanceof检查时都会返回true**。


## others

### json的介绍

> 对象字面量和json比较像，这里我们对json做一个简单介绍。

JSON：JavaScript Object Notation（JavaScript对象表示形式）。

JSON和对象字面量的区别：JSON的属性必须用双引号引号引起来，对象字面量可以省略。

json举例：

```
      {
            "name" : "zs",
            "age" : 18,
            "sex" : true,
            "sayHi" : function() {
                console.log(this.name);
            }
        };
```

注：json里一般放常量、数组、对象等，但很少放function。

另外，对象和json没有长度，json.length的打印结果是undefined。于是乎，自然也就不能用for循环遍历（因为便利时需要获取长度length）。

**json遍历的方法：**

json 采用 `for...in...`进行遍历，和数组的遍历方式不同。如下：


```html
<script>
    var myJson = {
        "name": "smyhvae",
        "aaa": 111,
        "bbb": 222
    };

    //json遍历的方法：for...in...
    for (var key in myJson) {
        console.log(key);   //获取 键
        console.log(myJson[key]); //获取 值（第二种属性绑定和获取值的方法）
        console.log("------");
    }
</script>
```

打印结果：

![](http://img.smyhvae.com/20180203_1518.png)


## 类和对象

函数并没有创建对象的能力，类才有。


```javascript
class Customer {
    //属性
    public String Name;
    public String Age;
    public String Money;

    //方法
    public void Buy (String id,int num,double price) {
        self.money -= num * price; //记录订单
    }
}
```


## new一个构造函数的过程

- 1.开辟对内存空间，创建一个新的对象

- 2.**把this设置为当前对象**

- 3.执行内部代码，设置对象属性和方法

- 4.返回新创建的对象


## 原型对象

### 原型的引入


```javascript
        function Person(name, age, gender) {
            this.name = name;
            this.age = age;
            this.gender = gender;
            //向对象中添加一个方法
            this.sayName = function () {
                console.log("我是" + this.name);
            }
        }

        //创建一个Person的实例
        var per = new Person("孙悟空", 18, "男");
        var per2 = new Person("猪八戒", 28, "男");
        per.sayName();
        per2.sayName();

        console.log(per.sayName == per2.sayName);  //打印结果为false
```

上方代码中，我们在Person中添加了一个sayName方法，然后在两个实例中进行了调用，造成的结果是：给每个实例都添加了sayName方法。

目前我们的sayName方法是在构造函数内部创建的，也就是说，**构造函数每执行一次就会创建一个新的sayName方法**。也是说所有实例的sayName都是唯一的，最后一行代码的打印结果为false。

还有一种方式是，将sayName方法在全局作用域中定义：（不建议。看注释）

```javascript
        function Person(name, age, gender) {
            this.name = name;
            this.age = age;
            this.gender = gender;
            //向对象中添加一个方法
            this.sayName = fun;
        }

        //将sayName方法在全局作用域中定义
        /*
         * 将函数定义在全局作用域，污染了全局作用域的命名空间
         * 	而且定义在全局作用域中也很不安全
         */
        function fun() {
            alert("Hello大家好，我是:" + this.name);
        };
```


比较好的方式是，在原型中添加sayName方法：

```javascript
	Person.prototype.sayName = function(){
		alert("Hello大家好，我是:"+this.name);
	};
```

### 原型prototype的概念

我们所创建的每一个函数，解析器都会向函数中添加一个属性prototype。这个属性对应着一个对象，这个对象就是我们所谓的原型对象。

如果函数作为普通函数调用prototype没有任何作用，当函数以构造函数的形式调用时，它所创建的实例对象中都会有一个隐含的属性，指向该构造函数的原型，我们可以通过__proto__来访问该属性。

原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象，我们可以将对象中共有的内容，统一设置到原型对象中。

当我们访问对象的一个属性或方法时，它会先在对象自身中寻找，如果有则直接使用，如果没有则会去原型对象中寻找，如果找到则直接使用。

以后我们创建构造函数时，可以将这些对象共有的属性和方法，统一添加到构造函数的原型对象中，这样就不用分别为每一个对象添加，也不会影响到全局作用域，就可以使每个对象都具有这些属性和方法了。


### 原型链

原型对象也是对象，所以它也有原型，当我们使用一个对象的属性或方法时，会现在自身中寻找，自身中如果有，则直接使用。如果没有则去原型对象中寻找。如果原型对象中有，则使用，如果没有则去原型的原型中寻找,直到找到Object对象的原型。Object对象的原型没有原型，如果在Object原型中依然没有找到，则返回undefined。





